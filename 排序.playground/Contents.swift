//: A UIKit based Playground for presenting user interface
  
import UIKit
import PlaygroundSupport

let arr: [Int] = [6,17,26,18,19,39,1,6,14,3,40]
let sortArr: [Int] = bubblingSort(array: arr)
let systemSort = arr.sorted()
print("swift系统排序:   \(systemSort) ")
print("--n到0的和-- \(sum(num: 11))")

let arr2: [Int] = [1,16,23,56,89,33,7,27,55,37,48]
print("排序前：  \(arr2)")
selectedSort(array: arr2)

let arr3: [Int] = [5,2,56,23,76,33,54,3]
//swift 是值传递
maopao(array: arr3)
print("aaa  \(arr3)")
xuanze(array: arr3)

func maopao(array: [Int]) {
    var arr: [Int] = array
    for i in 0..<arr.count {
        for j in 0..<arr.count-1-i {
            if arr[j]>arr[j+1] {
                arr.swapAt(j, j+1)
            }
        }
    }
    print("====  \(arr)")
}


func xuanze(array: [Int]) {
    var arr: [Int] = array
    var min = 0
    for i in 0..<arr.count-1 {
        min = i
        for j in i+1..<arr.count {
            if arr[j]<arr[min] {
                min = j
            }
        }
        if min != i {
            arr.swapAt(min, i)
        }
    }
    print("ccc  \(arr)")
    
}




func bubblingSort(array: [Int]) -> [Int] {
    var arr: [Int] = array
    for j in 0..<arr.count {
        print("j= \(j)")
        for i in 0..<arr.count-j-1 {
            if arr[i] > arr[i+1] {
                arr.swapAt(i, i+1)
            }
            print("     i= \(i): \(arr)")
        }
    }
    print("冒泡排序:        \(arr) ")
    return arr
}

func sum(num: Int) -> Int {
    var he = 0
    for i in 0..<num {
        he = he + i
    }
    return he
}

/// 选择排序
///
/// - Parameter array: 需要排序的数组
func selectedSort(array: [Int]) {
    var arr = array
    //记录最小值的下标
    var min = 0;
    for i in 0..<arr.count-1 {
        min = i
        for j in i+1..<arr.count {
            if arr[j] < arr[min] {
                min = j
            }
            //print("i:\(i),j:\(j)  \(arr)")
        }
        if min != i {
            arr.swapAt(i, min)
        }
    }
    print("选择排序：    \(arr)")
}

/*

     1, 16, 23, 56, 89, 33, 7, 27, 55, 37, 48
 i=0://第一轮 min = 0
    j=1: 1(m), 16(🚩), 23, 56, 89, 33, 7, 27, 55, 37, 48
    j=2: 1(m), 16, 23(🚩), 56, 89, 33, 7, 27, 55, 37, 48
    j=3: 1(m), 16, 23, 56(🚩), 89, 33, 7, 27, 55, 37, 48
    j=4: 1(m), 16, 23, 56, 89(🚩), 33, 7, 27, 55, 37, 48
    j=5: 1(m), 16, 23, 56, 89, 33(🚩), 7, 27, 55, 37, 48
    j=6: 1(m), 16, 23, 56, 89, 33, 7(🚩), 27, 55, 37, 48
    j=7: 1(m), 16, 23, 56, 89, 33, 7, 27(🚩), 55, 37, 48
    j=8: 1(m), 16, 23, 56, 89, 33, 7, 27, 55(🚩), 37, 48
    j=9: 1(m), 16, 23, 56, 89, 33, 7, 27, 55, 37(🚩), 48
    j=10: 1(m), 16, 23, 56, 89, 33, 7, 27, 55, 37, 48(🚩)
第一轮比较完成结果：(找到最小值1，放到第一个位置,共比较了 n-1 次)
          1(m), 16, 23, 56, 89, 33, 7, 27, 55, 37, 48
 
 i=1://第二轮 min = 1
    j=2: 1(🦁️), 16(m), 23(🚩), 56, 89, 33, 7, 27, 55, 37, 48
    j=3: 1(🦁️), 16(m), 23, 56(🚩), 89, 33, 7, 27, 55, 37, 48
    j=4: 1(🦁️), 16(m), 23, 56, 89(🚩), 33, 7, 27, 55, 37, 48
    j=5: 1(🦁️), 16(m), 23, 56, 89, 33(🚩), 7, 27, 55, 37, 48
    j=6: 1(🦁️), 16(m), 23, 56, 89, 33, 7(🚩), 27, 55, 37, 48
    j=7: 1(🦁️), 16, 23, 56, 89, 33, 7(m), 27(🚩), 55, 37, 48
    j=8: 1(🦁️), 16, 23, 56, 89, 33, 7(m), 27, 55(🚩), 37, 48
    j=9: 1(🦁️), 16, 23, 56, 89, 33, 7(m), 27, 55, 37(🚩), 48
    j=10: 1(🦁️), 16, 23, 56, 89, 33, 7(m), 27, 55, 37, 48(🚩)
     交换  1(🦁️), 7(m), 23, 56, 89, 33, 16, 27, 55, 37, 48
 
 第二轮比较结果：
         1(🦁️), 7(m), 23, 56, 89, 33, 16, 27, 55, 37, 48
 
 i=2://第三轮 min = 2
     j=3:1(🦁️), 7(🦁️), 23(m), 56(🚩), 89, 33, 16, 27, 55, 37, 48
     j=4:1(🦁️), 7(🦁️), 23(m), 56, 89(🚩), 33, 16, 27, 55, 37, 48
     j=5:1(🦁️), 7(🦁️), 23(m), 56, 89, 33(🚩), 16, 27, 55, 37, 48
     j=6:1(🦁️), 7(🦁️), 23(m), 56, 89, 33, 16(🚩), 27, 55, 37, 48
     j=7:1(🦁️), 7(🦁️), 23, 56, 89, 33, 16(m), 27(🚩), 55, 37, 48
     j=8:1(🦁️), 7(🦁️), 23, 56, 89, 33, 16(m), 27, 55(🚩), 37, 48
     j=8:1(🦁️), 7(🦁️), 23, 56, 89, 33, 16(m), 27, 55, 37(🚩), 48
     j=8:1(🦁️), 7(🦁️), 23, 56, 89, 33, 16(m), 27, 55, 37, 48(🚩)
     交换:1(🦁️), 7(🦁️), 16(m), 56, 89, 33, 23, 27, 55, 37, 48(🚩)
 
 第三轮比较结果：
         1(🦁️), 7(🦁️), 16(m), 56, 89, 33, 23, 27, 55, 37, 48
 
 i=3://第四轮  min = 3
    j=4:1(🦁️), 7(🦁️), 16(🦁️), 56(m), 89(🚩), 33, 23, 27, 55, 37, 48
    j=5:1(🦁️), 7(🦁️), 16(🦁️), 56(m), 89, 33(🚩), 23, 27, 55, 37, 48
    j=6:1(🦁️), 7(🦁️), 16(🦁️), 56, 89, 33, 23(🚩), 27, 55, 37, 48
    j=7:1(🦁️), 7(🦁️), 16(🦁️), 56, 89, 33, 23(m), 27(🚩), 55, 37, 48
    j=8:1(🦁️), 7(🦁️), 16(🦁️), 56, 89, 33, 23(m), 27, 55(🚩), 37, 48
    j=9:1(🦁️), 7(🦁️), 16(🦁️), 56, 89, 33, 23(m), 27, 55, 37(🚩), 48
    j=10:1(🦁️), 7(🦁️), 16(🦁️), 56, 89, 33, 23(m), 27, 55, 37, 48(🚩)
    交换：1(🦁️), 7(🦁️), 16(🦁️), 23(m), 89, 33, 56, 27, 55, 37, 48
 
 第四轮比较结果：
    1(🦁️), 7(🦁️), 16(🦁️), 23(m), 89, 33, 56, 27, 55, 37, 48
*/

/*
 插入排序
 把待排序的数组分成两部分，前一部分是排好序的，初始的时候，前一部分数据只有第一个数据。然后用依次取后面的数据与前面的有序序列比较，插入到相应的位置。
 
 12，15，9，20，6，31，24
 
 从小到大排序
 
初始： [12] 15(🚩)，9，20，6，31，24
 第一次排序：[12,15],9(🚩)，20，6，31，24
 第二次排序：[9,12,15],20(🚩)，6，31，24
 第三次排序：[9,12,15,20],6(🚩)，31，24
 第四次排序：[6,9,12,15,20],31(🚩),24
 第五次排序：[6,9,12,15,20,31],24(🚩)
 第六次排序：[6,9,12,15,20,24,31]
 */

print("\n\n\n")

let arr4: [Int] = [12,15,9,20,6,31,24]
let arr4S = insertSort(array: arr4)

/// 插入排序
///
/// - Parameter array: 排序前的数组
/// - Returns: 排序后的数组
func insertSort(array: [Int]) -> [Int] {
    var arr: [Int] = array
    for i in 0..<arr.count {
        var j: Int = i //确定当前坑的位置
        let temp: Int = arr[j] //目标出列
        while j>0, temp<arr[j-1] {
            arr[j] = arr[j-1]
            j = j-1  //向前移动
        }
        arr[j] = temp //目标进坑
    }
    
    print("插入排序： \(arr)")
    return arr
}


/*
 i=0:
     j=0 temp=arr[0]=12
     while j>0,arr[0]<arr[0-1] 不成立
     arr[0] = arr[0] =12
 i=1:
     j=1 temp = arr[1]=15
     while 1>0, arr[1]=15 < arr[1-1]=12 不成立
     arr[1] = 15
 i=2:
    j=2 temp = arr[2] = 9
    while 2>0, arr[2]=9 < arr[2-1]=15 成立
     arr[2] = arr[1] = 15
     j=j-1=1
    while 1>0, temp=9 < arr[j-1]=arr[0]=12 成立
     arr[1] = arr[j-1]=arr[0]=12
     j=j-1=1-1=0
    while 0>0, 不成立
    arr[0] = temp = 9
 
 [9,12,15],20,6,31,24
 
 */
















